# 문제1

###### 문제 설명

N개의 집이 원형으로 세워져 있는 마을이 있습니다. 각 집에는 1부터 N까지 순서대로 번호가 붙어 있습니다. 이 마을에서 바로 옆에 위치한 집으로 이동하는 데는 1 만큼의 단위 시간이 걸립니다. 또 집과 집 사이를 오가기 위해서는 중간에 위치한 집들을 반드시 거쳐서 이동해야 합니다. 다음은 N = 5인 경우의 예시입니다.
![image](https://res.cloudinary.com/dpxurmkij/image/upload/c_scale,w_250/v1492446414/%EA%B0%80%EC%A0%95%EB%B0%A9%EB%AC%B8_zau0c7.png)
위 그림에서 1번 집에서 2번 집, 또는 5번 집으로 이동하는 데는 1의 시간이 소요됩니다. 또 1번 집에서 3번 집으로 이동하기 위해서는 시계방향으로 2번 집을 거쳐 가거나, 혹은 반시계방향으로 5번과 4번 집을 거쳐서 이동해야 합니다. 따라서 1번 집에서 3번 집으로 이동하는 데는 2 또는 3의 시간이 소요됩니다.
이 마을을 방문한 한 여행자가 현재 1번 집 앞에 있습니다. 이 여행자는 이 마을에 있는 모든 집을 미리 정해진 순서대로 방문하려고 합니다. 예를 들어 위 예시에서 여행자가 미리 방문하기로 한 집의 순서가 [1, 2, 3, 4, 5]라면 1번 집부터 시계방향으로 각 집을 방문하면 총 4의 단위 시간에 모든 집을 방문할 수 있습니다. 만약 미리 방문하기로 한 집의 순서가 [3, 5, 4, 1, 2]라면 다음과 같은 순서로 모든 집을 방문할 수 있습니다.

- 여행자는 처음에 1번 집 앞에 있으며, 시계방향으로 2번 집을 거쳐 3번 집으로 이동하면 2의 시간이 소요됩니다.
- 3번 집에서 시계방향으로 4번 집을 거쳐 5번 집으로 이동하면 2의 시간이 소요됩니다.
- 5번 집에서 반시계방향으로 4번 집으로 이동하면 1의 시간이 소요됩니다.
- 4번 집에서 시계방향으로 5번 집을 거쳐 1번 집으로 이동하면 2의 시간이 소요됩니다.
- 1번 집에서 시계방향으로 2번 집으로 이동하면 1의 시간이 소요됩니다.

위 방법대로 이동하면 총 8의 시간이 소요되며, 이때가 모든 집을 미리 정해진 순서대로 방문하는데 걸리는 시간의 최솟값이 됩니다.

마을에 원형으로 세워져 있는 집의 개수 N과 여행자가 모든 집을 방문하기 위해 미리 정해둔 순서가 들어있는 배열 sequence가 매개변수로 주어질 때, 여행자가 미리 정해둔 순서대로 모든 집을 방문하는 데 필요한 시간의 최솟값을 return 하도록 solution 함수를 완성해주세요.

##### 제한 사항

- N은 2 이상 1,000 이하의 자연수입니다.
- 여행자는 sequence에 들어있는 번호 순서대로 각 집을 방문합니다.
- sequence의 길이는 N입니다.
- sequence에는 중복된 숫자가 들어있지 않습니다. 즉, 모든 집은 반드시 한 번씩 방문하며, 같은 집을 두 번 이상 방문하지 않습니다.
- 시간은 집에서 집으로 이동하는데 걸리는 시간만 고려합니다.

##### 입출력 예

| N    | sequence    | result |
| ---- | ----------- | ------ |
| 5    | [1,2,3,4,5] | 4      |
| 5    | [3,5,4,1,2] | 8      |

##### 입출력 예 설명

입출력 예 #1
문제의 예시와 같습니다.

입출력 예 #2
문제의 예시와 같습니다.

## 코드

```python

```







# 문제2

###### 문제 설명

자연수 N개가 중복없이 들어있는 배열이 있습니다. 이때, 서로 다른 두 원소의 위치를 바꾸는 Swap 연산을 이용해 원소들의 위치를 바꿔 서로 인접한 원소의 차가 K 이하가 되도록 하려 합니다. 단, Swap 연산을 최대한 적게 사용해야 합니다

배열 numbers가 매개변수로 주어질 때, 서로 인접한 원소의 차가 K 이하가 되도록 하는데 필요한 Swap 횟수의 최솟값을 return 하도록 solution 함수를 완성해주세요.

##### 제한사항

- numbers의 길이(N)는 1 이상 8 이하입니다.
- numbers의 원소는 1 이상 100 이하인 자연수입니다.
  - 숫자는 중복없이 들어있습니다.
- K는 1 이상 100 이하인 자연수입니다.
- 서로 인접한 원소의 차가 K 이하가 되도록 할 수 있는 방법이 없다면 -1을 return 하세요.

------

##### 입출력 예

| numbers                  | k    | result |
| ------------------------ | ---- | ------ |
| [10, 40, 30, 20]         | 20   | 1      |
| [3, 7, 2, 8, 6, 4, 5, 1] | 3    | 2      |

##### 입출력 예 설명

입출력 예 #1
30과 40의 위치를 바꾸면 [10, 30, 40, 20]이 되며, 인접한 원소의 차가 모두 20 이하가 됩니다.

입출력 예 #2
3과 4의 위치를 바꾸고, 2와 5의 위치를 바꾸면 [4, 7, 5, 8, 6, 3, 2, 1]이 되며, 인접한 원소의 차가 모두 3 이하가 됩니다.



## 문제3

###### 문제 설명

흰색 또는 검은색 모자를 쓴 사람들이 한 줄로 서있습니다. 모든 사람은 바로 앞, 뒤에 있는 사람이 쓴 모자 색만 확인할 수 있으며, 자신이 쓴 모자가 무슨 색인지는 알 수 없습니다. 물론, 가장 앞에 있는 사람은 바로 뒤에 있는 사람이 쓴 모자색만 확인할 수 있으며, 가장 뒤에 있는 사람은 바로 앞에 있는 사람이 쓴 모자색만 확인할 수 있습니다. 이때, 가장 앞에 있는 사람부터 자신이 본 검은색 모자 개수를 말하기 시작했습니다.

- 첫 번째 사람 : 나는 검은색 모자를 x개 볼 수 있어
- 두 번째 사람 : 나는 검은색 모자를 y개 볼 수 있어
- ...
- 마지막 사람 : 나는 검은색 모자를 z개 볼 수 있어

첫 번째 사람부터 순서대로 말한 검은색 모자 개수가 담긴 배열 black_caps가 매개변수로 주어집니다. 확실하게 검은색 모자를 쓴 사람은 1, 확실하게 흰색 모자를 쓴 사람은 2, 어떤 모자를 썼는지 알 수 없는 사람은 0으로 표시한 배열을 return 하도록 solution 함수를 완성해주세요.

##### 제한사항

- black_caps의 길이는 3 이상 200,000 이하입니다.
- black_caps의 원소는 0 이상 2 이하인 정수입니다.
- 각 사람이 말한 검은색 모자 개수가 모순이 없는 경우만 입력으로 주어집니다.

------

##### 입출력 예

| black_caps   | result       |
| ------------ | ------------ |
| [1, 1, 2, 0] | [1, 1, 2, 1] |
| [1, 1, 1]    | [0, 1, 0]    |

##### 입출력 예 설명

입출력 예 #1

첫 번째, 두 번째, 네 번째 사람은 확실하게 검은 모자를 썼으며, 세 번째 사람은 확실하게 흰 모자를 썼습니다.

입출력 예 #2

두 번째 사람은 확실하게 검은 모자를 썼으며, 첫 번째, 세 번째 사람이 쓴 모자색은 알 수 없습니다

```python
def soultion(black_caps):
    a=black_caps
    b= [0] * len(a)
    if a[0]==1:
        b[1]=1
    elif a[0]==0:
        b[1]=2
    elif a[-1] == 0:
        b[-2] = 2
    elif a[-1] == 1:
        b[-2] = 1
    for i in range(1,len(a)-1):
        if a[i] == 2:
            b[i-1]=1
            b[i+1]=1
        elif a[i] == 0:
            b[i-1]=2
            b[i+1]=2
    if b[1] == 1 and b[2]==2:
        b[0]=1


    return b

```



## 문제4

`CHARACTERS` 테이블은 XX런게임에서 살 수 있는 캐릭터의 정보를 담고 있는 테이블입니다. `CHARACTERS` 테이블 구조는 다음과 같으며, `NAME`, `SPEED`, `BOOST_SPEED`, `BOOST_TIME`, `PRICE`는 각각 캐릭터의 이름, 속도, 부스트 속도, 부스트 지속 시간, 가격을 나타냅니다.

| NAME        | TYPE    |
| ----------- | ------- |
| NAME        | VARCHAR |
| SPEED       | INT     |
| BOOST_SPEED | INT     |
| BOOST_TIME  | INT     |
| PRICE       | INT     |

`PURCHASES` 테이블은 XX런 게임의 유료 캐릭터 구매내역을 담고 있는 테이블입니다. `PURCHASES` 테이블의 구조는 다음과 같으며, `ID`, `USER_ID`, `PURCHASE_DATE`, `ITEM`은 각각 ID, 유저의 ID, 구매 날짜, 산 캐릭터의 이름을 나타냅니다.

| NAME          | TYPE     |
| ------------- | -------- |
| ID            | INT      |
| USER_ID       | VARCHAR  |
| PURCHASE_DATE | DATETIME |
| ITEM          | VARCHAR  |

`CHARACTERS` 테이블에 있는 모든 캐릭터에 대해, 캐릭터의 이름과 해당 캐릭터가 구입된 횟수를 조회하는 쿼리를 작성해주세요. 결과는 캐릭터의 이름 순으로 조회되어야 하며, 한 번도 구입되지 않은 캐릭터가 구입된 횟수는 0으로 나와야 합니다.

##### 예시

예를 들어, `CHARACTERS` 테이블, `PURCHASES` 테이블이 다음과 같다면

```
CHARACTERS
```

| NAME      | SPEED | BOOST_SPEED | BOOST_TIME | PRICE |
| --------- | ----- | ----------- | ---------- | ----- |
| Albatross | 198   | 447         | 12         | 1000  |
| Bee       | 201   | 472         | 7          | 3000  |

```
PURCHASES
```

| ID   | USER_ID | PURCHASE_DATE       | ITEM |
| ---- | ------- | ------------------- | ---- |
| 1    | user2   | 2016-12-11 10:30:05 | Bee  |
| 2    | user1   | 2016-11-16 23:23:32 | Bee  |

Albatross 는 한 번도 구입된 적이 없습니다.
Bee는 두 번 구입되었습니다.

따라서 이때는 SQL을 실행하면 다음과 같이 출력되어야 합니다.

| NAME      | CNT  |
| --------- | ---- |
| Albatross | 0    |
| Bee       | 2    |



## 코드

```sql
select name, count(name) as Total from CHARACTERS as a LEFT OUTER JOIN PURCHASES as b on a.name=b.item
group by name
```

